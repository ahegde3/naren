/* * Copyright (C) 2011 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.samsung.android.emailcommon.utility;import android.content.ContentResolver;import android.content.ContentUris;import android.content.Context;import android.database.Cursor;import android.net.Uri;import android.text.TextUtils;import android.webkit.MimeTypeMap;import com.samsung.android.emailcommon.Logging;import com.samsung.android.emailcommon.provider.EmailContent.Attachment;import com.samsung.android.emailcommon.provider.EmailContent.Message;import com.samsung.android.emailcommon.provider.EmailContent.MessageColumns;import com.samsung.android.emailcommon.system.CarrierValues;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Locale;public class AttachmentUtilities {    private static final String TAG = "AttachmentUtilities";    public static final String AUTHORITY = "com.samsung.android.email.attachmentprovider";    public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY);    public static final String FORMAT_RAW = "RAW";    public static final String FORMAT_THUMBNAIL = "THUMBNAIL";    public static final String DELETE_FILE = "DELETE_FILE";    public static final String DELETE_PART = "DELETE_PART";    public static final String DELETE_FOLDER = "DELETE_FOLDER";    // MNO_B2B Start : karthik.k    // Format and extension for part file    public static final String FORMAT_PART = "PART";    public static final String FORMAT_WIDTH = "WIDTH";    public static final String PART_FILE_EXT = ".part";    // MNO_B2B End    public static class Columns {        public static final String _ID = "_id";        public static final String DATA = "_data";        public static final String DISPLAY_NAME = "_display_name";        public static final String SIZE = "_size";    }    /**     * The MIME type(s) of attachments we're willing to send via attachments.     * Any attachments may be added via Intents with Intent.ACTION_SEND or     * ACTION_SEND_MULTIPLE.     */    public static final String[] ACCEPTABLE_ATTACHMENT_SEND_INTENT_TYPES = new String[] {        "*/*",    };    /**     * The MIME type(s) of attachments we're willing to send from the internal     * UI. NOTE: At the moment it is not possible to open a chooser with a list     * of filter types, so the chooser is only opened with the first item in the     * list.     */    public static final String[] ACCEPTABLE_ATTACHMENT_SEND_UI_TYPES = new String[] {            "image/*", "video/*",    };    /**     * The MIME type(s) of attachments we're willing to view.     */    public static final String[] ACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[] {        "*/*",    };    /**     * The MIME type(s) of attachments we're not willing to view.     */    public static final String[] UNACCEPTABLE_ATTACHMENT_VIEW_TYPES = new String[] {};    /**     * The MIME type(s) of attachments we're willing to download to SD.     */    public static final String[] ACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[] {            "*/*",            // change@wtl.jpshu document search begin            "text/*", "html/*",    // change@wtl.jpshu document search end    };    /**     * The MIME type(s) of attachments we're not willing to download to SD.     */    public static final String[] UNACCEPTABLE_ATTACHMENT_DOWNLOAD_TYPES = new String[] {};    /**     * Filename extensions of attachments we're never willing to download     * (potential malware). Entries in this list are compared to the end of the     * lower-cased filename, so they must be lower case, and should not include     * a "."     */    public static final String[] UNACCEPTABLE_ATTACHMENT_EXTENSIONS = new String[] {            // File types that contain malware            "ade", "adp", "bat", "chm", "cmd", "com", "cpl", "dll", "exe", "hta", "ins", "isp",            "jse", "lib", "mde", "msc", "msp", "mst", "pif", "scr", "sct", "shb", "sys", "vb",            "vbe", "vbs", "vxd", "wsc", "wsf", "wsh",            // File types of common compression/container formats (again, to            // avoid malware)            "zip", "gz", "z", "tar", "tgz", "bz2",    };    /**     * Filename extensions of attachments that can be installed. Entries in this     * list are compared to the end of the lower-cased filename, so they must be     * lower case, and should not include a "."     */    public static final String[] INSTALLABLE_ATTACHMENT_EXTENSIONS = new String[] {        "apk",    };    /**     * The maximum size of an attachment we're willing to download (either View     * or Save) Attachments that are base64 encoded (most) will be about 1.375x     * their actual size so we should probably factor that in. A 5MB attachment     * will generally be around 6.8MB downloaded but only 5MB saved.     */    // 2011.08.02 wsseo : size restriction (10MB -> 50MB) - start    public static final int MAX_ATTACHMENT_DOWNLOAD_SIZE = (50 * 1024 * 1024);    // 2011.08.02 wsseo : size restriction (10MB -> 50MB) - end    public static final int MAX_ATTACHMENT_COUNT = 250;    public static final int MAX_ATTACHMENT_UPLOAD_SIZE = (50 * 1024 * 1024);    public static final int ATTACHMENT_SIZE_1MB = (1 * 1024 * 1024);    public static final int MAX_THRESHOLD_ATTACHMENT_UPLOAD_SIZE = (100 * 1024 * 1024);    public static final int MIN_THRESHOLD_ATTACHMENT_UPLOAD_SIZE = (10 * 1024 * 1024);    /**     * The maximum size of an attachment we're willing to upload (measured as     * stored on disk). Attachments that are base64 encoded (most) will be about     * 1.375x their actual size so we should probably factor that in. A 5MB     * attachment will generally be around 6.8MB uploaded.     */    public static int getCarrierSpecificMaxAttachmentUploadSize() {        if (CarrierValues.IS_CARRIER_USC) {            return 5 * 1024 * 1024;        } else if (SecFeatureWrapper.getCarrierId() == SecFeatureWrapper.CARRIER_H3G                || SecFeatureWrapper.getCarrierId() == SecFeatureWrapper.CARRIER_DRE                || SecFeatureWrapper.getCarrierId() == SecFeatureWrapper.CARRIER_HUI                || SecFeatureWrapper.getCarrierId() == SecFeatureWrapper.CARRIER_3IE) {            return 10 * 1024 * 1024;        }        return 0;    }    public static int getMaxAttachmentUploadSize() {        int size = getCarrierSpecificMaxAttachmentUploadSize();        if (size > 0) {            return size;        }        return MAX_ATTACHMENT_UPLOAD_SIZE;    }    public static int getMaxAttachmentUploadSize(boolean isSncAccount) {        if (CarrierValues.IS_CARRIER_VZW && isSncAccount) {            return 10 * 1024 * 1024;        }        return getMaxAttachmentUploadSize();    }    public static Uri getAttachmentUri(long accountId, long id) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(Long.toString(id)).appendPath(FORMAT_RAW).build();    }    public static Uri getAttachmentThumbnailUri(long accountId, long id, int width, int height) {        return getAttachmentThumbnailUri(accountId, id, width, height, false);    }    public static Uri getAttachmentThumbnailUri(long accountId, long id, int width, int height,            boolean reset) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(Long.toString(id)).appendPath(FORMAT_THUMBNAIL)                .appendPath(Integer.toString(width)).appendPath(Integer.toString(height))                .appendPath(reset ? "1" : "0").build();    }    public static Uri getAttachmentDeleteUri(long accountId, long attachmentId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(Long.toString(attachmentId)).appendPath(DELETE_FILE).build();    }    public static Uri getAttachmentPartFileDeleteUri(long accountId, long attachmentId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(Long.toString(attachmentId)).appendPath(DELETE_PART).build();    }    public static Uri getAttachmentsDeleteUri(long accountId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(DELETE_FOLDER).build();    }    public static Uri getAttachmentAllDeleteUri(long accountId, long messageId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(Long.toString(messageId)).build();    }    public static Uri getAccountAttachmentDeleteUri(long accountId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId)).build();    }    public static boolean isExist(Context context, long accountId, long attachmentId) {        if (context == null) {            return false;        }        boolean exist = false;        InputStream is = null;        try {            is = getInputStream(context, accountId, attachmentId);            if (is != null) {                exist = true;            }        } finally {            if (is != null) {                try {                    is.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return exist;    }    public static boolean isExistPartFile(Context context, long accountId, long attachmentId) {        if (context == null) {            return false;        }        boolean exist = false;        InputStream is = null;        try {            is = getPartFileInputStream(context, accountId, attachmentId);            if (is != null) {                exist = true;            }        } finally {            if (is != null) {                try {                    is.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return exist;    }    public static InputStream getInputStream(Context context, long accountId, long attachmentId) {        if (context == null) {            return null;        }        InputStream in = null;        try {            in = context.getContentResolver().openInputStream(                    AttachmentUtilities.getAttachmentUri(accountId, attachmentId));        } catch (FileNotFoundException e) {            e.printStackTrace();        }        return in;    }    public static OutputStream getOutputStream(Context context, long accountId, long attachmentId) {        if (context == null) {            return null;        }        OutputStream os = null;        try {            os = context.getContentResolver().openOutputStream(                    AttachmentUtilities.getAttachmentUri(accountId, attachmentId));        } catch (FileNotFoundException e) {            e.printStackTrace();        }        return os;    }    public static InputStream getPartFileInputStream(Context context, long accountId,            long attachmentId) {        if (context == null) {            return null;        }        InputStream in = null;        try {            in = context.getContentResolver().openInputStream(                    AttachmentUtilities.getAttachmentPartFileUri(accountId, attachmentId));        } catch (FileNotFoundException e) {            Log.e(TAG, String.format("getPartFileInputStream error(%s)", e.getMessage()));        }        return in;    }    public static OutputStream getPartFileOutputStream(Context context, long accountId,            long attachmentId) {        if (context == null) {            return null;        }        OutputStream os = null;        try {            os = context.getContentResolver().openOutputStream(                    AttachmentUtilities.getAttachmentPartFileUri(accountId, attachmentId));        } catch (FileNotFoundException e) {            Log.e(TAG, String.format("getPartFileInputStream error(%s)", e.getMessage()));        }        return os;    }    public static boolean deleteAttachment(Context context, long accountId, long attachmentId) {        if (context == null) {            return false;        }        return context.getContentResolver().delete(getAttachmentDeleteUri(accountId, attachmentId),                null, null) == 1;    }    public static boolean deleteAttachmentPartFile(Context context, long accountId,            long attachmentId) {        if (context == null) {            return false;        }        return context.getContentResolver().delete(                getAttachmentPartFileDeleteUri(accountId, attachmentId), null, null) == 1;    }    static public int getAttachmentPartFileSize(Context context, long accountId, long attachmentId) {        int size = 0;        Cursor c = null;        try {            c = context.getContentResolver().query(                    getAttachmentPartFileUri(accountId, attachmentId), null, null, null, null);            if (c != null && c.moveToFirst()) {                size = c.getInt(0);            }        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        return size;    }    // MNO_B2B Start : karthik.k    public static File getAttachmentFilename(Context context, long accountId, long attachmentId) {        return new File(getAttachmentDirectory(context, accountId), Long.toString(attachmentId));    }    /**     * Return the directory for a given attachment. This should be used by any     * code that is going to *write* attachments. This does not create or write     * the directory. It simply builds the pathname that should be used.     */    public static File getAttachmentDirectory(Context context, long accountId) {        if (context == null) {            return null;        }        File directory = new File(Utility.getSdpCacheDir(context), accountId + ".db_att"); // ?.db_att                                                                                 // directory                                                                                 // moves                                                                                 // to                                                                                 // cache-directory                                                                                 // |jh.rhim        return directory;        // return context.getDatabasePath(accountId + ".db_att"); //sec.email        // tom.jung 20100809 To change directory path from OneNand to MobiNand    }    /**     * @param accountId     * @param attachmentId     * @return URI of the part file used to store partially loaded attachment     */    public static Uri getAttachmentPartFileUri(long accountId, long attachmentId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))                .appendPath(Long.toString(attachmentId)).appendPath(FORMAT_PART).build();    }    // MNO_B2B End    public static String getAttachmentFullPath(Context context, long accountId, long attachmentId) {        String fullpath = Utility.getSdpCacheDir(context).getPath() + "/" + Long.toString(accountId)                + ".db_att/" + Long.toString(attachmentId);        return fullpath;    }    public static String getAttachmentTempForDrm(Context context, long accountId) {        String fullpath = Utility.getSdpCacheDir(context).getPath() + "/" + Long.toString(accountId)                + ".db_att/";        return fullpath;    }    /**     * Helper to convert unknown or unmapped attachments to something useful     * based on filename extensions. The mime type is inferred based upon the     * table below. It's not perfect, but it helps.     *     * <pre>     *                   |---------------------------------------------------------|     *                   |                  E X T E N S I O N                      |     *                   |---------------------------------------------------------|     *                   | .eml        | known(.png) | unknown(.abc) | none        |     * | M |-----------------------------------------------------------------------|     * | I | none        | msg/rfc822  | image/png   | app/abc       | app/oct-str |     * | M |-------------| (always     |             |               |             |     * | E | app/oct-str |  overrides  |             |               |             |     * | T |-------------|             |             |-----------------------------|     * | Y | text/plain  |             |             | text/plain                  |     * | P |-------------|             |-------------------------------------------|     * | E | any/type    |             | any/type                                  |     * |---|-----------------------------------------------------------------------|     * </pre>     *     * NOTE: Since mime types on Android are case-*sensitive*, return values are     * always in lower case.     *     * @param fileName The given filename     * @param mimeType The given mime type     * @return A likely mime type for the attachment     */    public static String inferMimeType(final String fileName, final String mimeType) {        String resultType = null;        String fileExtension = getFilenameExtension(fileName);        boolean isTextPlain;        if (mimeType != null) {            isTextPlain = "text/plain".equalsIgnoreCase(mimeType);        } else {            isTextPlain = false;            resultType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(fileExtension);        }        if ("eml".equals(fileExtension)) {            resultType = "message/rfc822";        } else if ("apk".equalsIgnoreCase(fileExtension)) {            resultType = "application/vnd.android.package-archive";        } else if ("vnt".equalsIgnoreCase(fileExtension)) {            resultType = "text/x-vnote";        } else if ("vts".equalsIgnoreCase(fileExtension)) {            resultType = "text/x-vtodo";        } else if ("htm".equalsIgnoreCase(fileExtension)) {            resultType = "text/html";        } else if ("html".equalsIgnoreCase(fileExtension)) {            resultType = "text/html";        } else if ("vcs".equalsIgnoreCase(fileExtension)) {            resultType = "text/x-vcalendar";        } else if ("ics".equalsIgnoreCase(fileExtension)) {            resultType = "text/calendar";        } else if ("webp".equalsIgnoreCase(fileExtension)) {            resultType = "image/webp";        } else if ("xlsx".equalsIgnoreCase(fileExtension)) {            resultType = "application/vnd.ms-excel";        } else if ("xls".equalsIgnoreCase(fileExtension)) {            resultType = "application/vnd.ms-excel";        } else if ("doc".equalsIgnoreCase(fileExtension)) {            resultType = "application/msword";        } else if ("docx".equalsIgnoreCase(fileExtension)) {            resultType = "application/msword";        } else if ("ppt".equalsIgnoreCase(fileExtension)) {            resultType = "application/vnd.ms-powerpoint";        } else if ("pptx".equalsIgnoreCase(fileExtension)) {            resultType = "application/vnd.ms-powerpoint";        } else if ("golf".equalsIgnoreCase(fileExtension)) {            resultType = "image/*";        } else if (mimeType != null && mimeType.equalsIgnoreCase("image/jpg") == true) {            resultType = "image/jpeg";        } else if (mimeType != null && mimeType.equalsIgnoreCase("image/x-png") == true) {            resultType = "image/png";        } else {            if (mimeType != null) {                boolean isGenericType = isTextPlain                        || "application/octet-stream".equalsIgnoreCase(mimeType);                // If the given mime type is non-empty and non-generic, return                // it                if (isGenericType || TextUtils.isEmpty(mimeType)) {                    if (!TextUtils.isEmpty(fileExtension)) {                        // Otherwise, try to find a mime type based upon the                        // file                        // extension                        resultType = MimeTypeMap.getSingleton().getMimeTypeFromExtension(                                fileExtension);                        if (TextUtils.isEmpty(resultType)) {                            // Finally, if original mimetype is text/plain, use                            // it;                            // otherwise synthesize                            resultType = isTextPlain ? mimeType : "application/" + fileExtension;                        }                    }                } else {                    resultType = mimeType;                }            }        }        // No good guess could be made; use an appropriate generic type        if (TextUtils.isEmpty(resultType)) {            resultType = isTextPlain ? "text/plain" : "application/octet-stream";        }        return resultType.toLowerCase(Locale.ENGLISH);    }    /**     * @return mime-type for a {@link Uri}. - Use     *         {@link ContentResolver#getType} for a content: URI. - Use     *         {@link #inferMimeType} for a file: URI. - Otherwise throw     *         {@link IllegalArgumentException}.     */    public static String inferMimeTypeForUri(Context context, Uri uri) {        final String scheme = uri.getScheme();        if ("content".equals(scheme)) {            return context.getContentResolver().getType(uri);        } else if ("file".equals(scheme)) {            return inferMimeType(uri.getLastPathSegment(), "");        } else {            throw new IllegalArgumentException();        }    }    /**     * Extract and return filename's extension, converted to lower case, and not     * including the "."     *     * @return extension, or null if not found (or null/empty filename)     */    public static String getFilenameExtension(String fileName) {        String extension = null;        if (!TextUtils.isEmpty(fileName)) {            int lastDot = fileName.lastIndexOf('.');            if ((lastDot > 0) && (lastDot < fileName.length() - 1)) {                extension = fileName.substring(lastDot + 1).toLowerCase();            }        }        return extension;    }    /**     * Resolve attachment id to content URI. Returns the resolved content URI     * (from the attachment DB) or, if not found, simply returns the incoming     * value.     *     * @param attachmentUri     * @return resolved content URI TODO: Throws an SQLite exception on a     *         missing DB file (e.g. unknown URI) instead of just returning the     *         incoming uri, as it should.     */    public static Uri resolveAttachmentIdToContentUri(ContentResolver resolver, Uri attachmentUri) {        Cursor c = resolver.query(attachmentUri, new String[] {            Columns.DATA        }, null, null, null);        if (c != null) {            try {                if (c.moveToFirst()) {                    final String strUri = c.getString(0);                    if (strUri != null) {                        return Uri.parse(strUri);                    }                }            } finally {                c.close();            }        }        return attachmentUri;    }    /**     * In support of deleting a message, find all attachments and delete     * associated attachment files.     *     * @param context     * @param accountId the account for the message     * @param messageId the message     */    public static void deleteAllAttachmentFiles(Context context, long accountId, long messageId) {        Uri uri = ContentUris.withAppendedId(Attachment.MESSAGE_ID_URI, messageId);        Cursor c = context.getContentResolver().query(uri, Attachment.ID_PROJECTION, null, null,                null);        try {            while (c.moveToNext()) {                long attachmentId = c.getLong(Attachment.ID_PROJECTION_COLUMN);                deleteAttachment(context, accountId, attachmentId);            }        } finally {            c.close();        }    }    /**     * In support of deleting a message, find all attachments and delete     * associated attachment files using ContentResolver instead of direct files     * access. This function is required for Exchange     *     * @param context     * @param accountId the account for the message     * @param messageId the message     */    public static void deleteAllAttachmentFilesUri(Context context, long accountId, long messageId) {        context.getContentResolver().delete(getAttachmentAllDeleteUri(accountId, messageId), null,                null);    }    /**     * In support of deleting a mailbox, find all messages and delete their     * attachments.     *     * @param context     * @param accountId the account for the mailbox     * @param mailboxId the mailbox for the messages     * @param useUriApi flag to use URI to delete files instead of direct access     *            to folder     */    public static void deleteAllMailboxAttachmentFiles(Context context, long accountId,            long mailboxId, boolean useUriApi) {        EmailLog.d(TAG, "deleteAllMailboxAttachmentFiles accountId = " + accountId                + " mailboxId = " + mailboxId);        Cursor c = context.getContentResolver().query(Message.CONTENT_URI,                Message.ID_COLUMN_PROJECTION, MessageColumns.MAILBOX_KEY + "=?", new String[] {                    Long.toString(mailboxId)                }, null);        try {            while (c.moveToNext()) {                long messageId = c.getLong(Message.ID_PROJECTION_COLUMN);                if (useUriApi) {                    deleteAllAttachmentFilesUri(context, accountId, messageId);                } else {                    deleteAllAttachmentFiles(context, accountId, messageId);                }            }        } finally {            c.close();        }    }    /**     * In support of deleting a mailbox, find all messages and delete their     * attachments.     *     * @param context     * @param accountId the account for the mailbox     * @param mailboxId the mailbox for the messages     * @param useUriApi flag to use URI to delete files instead of direct access     *            to folder     */    public static void deleteAllMailboxAttachmentFiles(Context context, long accountId,            long mailboxId) {        deleteAllMailboxAttachmentFiles(context, accountId, mailboxId, false);    }    /**     * In support of deleting or wiping an account, delete all related     * attachments.     *     * @param context     * @param accountId the account to scrub     */    // Delete attachment file after removing account start 20110325 johnny    public static void deleteAllAccountAttachmentFiles(Context context, long accountId) {        if (context == null) {            return;        }        context.getContentResolver().delete(getAttachmentsDeleteUri(accountId), null, null);    }    /**     * In support of deleting or wiping an account, delete all related     * attachments using URI. Required for Exchange     *     * @param context     * @param accountId the account to scrub     */    // Delete attachment file after removing account start 20110325 johnny    public static void deleteAllAccountAttachmentFilesUri(Context context, long accountId) {        context.getContentResolver().delete(getAccountAttachmentDeleteUri(accountId), null, null);    }    // MNO B2B Start J.sb    public static long getRawAttachmentSize(long size, boolean serverValue) {        if(serverValue)            return size;        else            return ((size * 3) / 4);    }    public static long getEncodedSize(long size) {        return ((size * 4) / 3);    }    public static long parseSizeAttributeOfCapabilities(String capabilities) {        if (capabilities == null) {            EmailLog.e(Logging.LOG_TAG, "SMTP capabilities is null");            return 0;        }        String[] resultList = capabilities.split("-");        String sizeString = "SIZE";        long size = 0;        if (resultList != null) {            try {                for (int i = 0; i < resultList.length; i++) {                    if (resultList[i].contains(sizeString)) {                        String[] sizeResultList = resultList[i].split(" ");                        int j;                        for (j = 0; j < sizeResultList.length; j++) {                            if (sizeResultList[j].equalsIgnoreCase(sizeString)) {                                break;                            }                        }                        String sizeValue = sizeResultList[j + 1].trim();                        size = Long.valueOf(sizeValue);                        break;                    }                }            } catch (Exception e) {                EmailLog.e(Logging.LOG_TAG, "Server limit size parsing failed ", e.getMessage());            }        }        return size;    }    // MNO B2B End    final static public String ATTACHMENT_STATUS_AUTHORITY = "com.samsung.android.email.attachmentstatusprovider";    final static public Uri ATTACHMENT_STATUS_URI = Uri.parse("content://"            + ATTACHMENT_STATUS_AUTHORITY);    final static public String ATTACHMENT_STATUS_QUENE_SIZE = "qsize";    final static public String ATTACHMENT_STATUS_IN_QUEUE = "isinq";    final static public String ATTACHMENT_STATUS_DEQUEUE = "deq";    final static public String ATTACHMENT_STATUS_REMOVE = "remove";    final static public String ATTACHMENT_PATH = "path";    final static public String ATTACHMENT_RENAME = "rename";    final static public String ATTACHMENT_EXIST = "exist";    final static public String ATTACHMENT_DRM = "drm";    static public int getQueueSize(Context context) {        int size = 0;        Cursor c = null;        try {            Uri uri = ATTACHMENT_STATUS_URI.buildUpon()                    .appendEncodedPath(ATTACHMENT_STATUS_QUENE_SIZE).build();            c = context.getContentResolver().query(uri, null, null, null, null);            if (c != null && c.moveToFirst()) {                size = c.getInt(0);            }        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        return size;    }    static public boolean isAttachmentQueued(Context context, long attachId) {        boolean val = false;        Cursor c = null;        try {            Uri uri = ATTACHMENT_STATUS_URI.buildUpon()                    .appendEncodedPath(ATTACHMENT_STATUS_IN_QUEUE).build();            c = context.getContentResolver().query(uri, null, null, new String[] {                String.valueOf(attachId)            }, null);            if (c != null && c.moveToFirst()) {                val = c.getInt(0) == 1;            }        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        return val;    }    static public int dequeue(Context context, long attachmentId) {        Uri uri = ATTACHMENT_STATUS_URI.buildUpon().appendEncodedPath(ATTACHMENT_STATUS_DEQUEUE)                .build();        Uri uri2 = ContentUris.withAppendedId(uri, attachmentId);        return context.getContentResolver().delete(uri2, null, null);    }    static public void removeTask(Context context, long messageId) {        if (messageId == -1)            return;        Uri uri = ATTACHMENT_STATUS_URI.buildUpon().appendEncodedPath(ATTACHMENT_STATUS_REMOVE)                .build();        Uri uri2 = ContentUris.withAppendedId(uri, messageId);        context.getContentResolver().delete(uri2, null, null);    }    static public String getAttachmentFullPathFromProvider(Context context, long accId) {        return getAttachmentFullPathFromProvider(context, accId, 0);    }    static public String getAttachmentFullPathFromProvider(Context context, long accId, long attId) {        String path = null;        Cursor c = null;        try {            Uri uri = ATTACHMENT_STATUS_URI.buildUpon().appendEncodedPath(ATTACHMENT_PATH)                    .appendEncodedPath(Long.toString(accId))                    .appendEncodedPath(Long.toString(attId)).build();            c = context.getContentResolver().query(uri, null, null, null, null);            if (c != null && c.moveToFirst()) {                path = c.getString(0);            }        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        return path;    }    static public void attachmentRenameUri(Context context, String src, String dst) {        Cursor c = null;        try {            Uri uri = ATTACHMENT_STATUS_URI.buildUpon().appendEncodedPath(ATTACHMENT_RENAME)                    .build();            c = context.getContentResolver().query(uri, null, null, new String[] {                    src, dst            }, null);        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        return;    }    static public boolean attachmentExistUri(Context context, String file) {        int rt = 0;        Cursor c = null;        try {            Uri uri = ATTACHMENT_STATUS_URI.buildUpon().appendEncodedPath(ATTACHMENT_EXIST).build();            c = context.getContentResolver().query(uri, null, null, new String[] {                file            }, null);            if (c != null && c.moveToFirst()) {                rt = c.getInt(0);            }        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        if (rt == 1)            return true;        else            return false;    }    static public boolean attachmentIsDRMUri(Context context, String file) {        int rt = 0;        Cursor c = null;        try {            Uri uri = ATTACHMENT_STATUS_URI.buildUpon().appendEncodedPath(ATTACHMENT_DRM).build();            c = context.getContentResolver().query(uri, null, null, new String[] {                file            }, null);            if (c != null && c.moveToFirst()) {                rt = c.getInt(0);            }        } catch (Exception ex) {            ex.printStackTrace();        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        if (rt == 1)            return true;        else            return false;    }    public static int[] getAttachmentWidth(Context context, long accountId, long attachmentId) {        int[] org_value = new int[2];        Cursor c = null;        try {            c = context.getContentResolver().query(getAttachmentWidthUri(accountId, attachmentId),                    null, null, null, null);            if (c != null && c.moveToFirst()) {                org_value[0] = c.getInt(0);                org_value[1] = c.getInt(1);            } else {                org_value[0] = 0;                org_value[1] = 0;            }        } catch (Exception ex) {            ex.printStackTrace();        } finally {            if (c != null && !c.isClosed()) {                c.close();            }        }        return org_value;    }    public static Uri getAttachmentWidthUri(long accountId, long attachmentId) {        return CONTENT_URI.buildUpon().appendPath(Long.toString(accountId))        .appendPath(Long.toString(attachmentId)).appendPath(FORMAT_WIDTH).build();    }}